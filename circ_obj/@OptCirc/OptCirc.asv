classdef (Abstract) OptCirc <  CircGoal & ...
                    OptNLBranch

% Interface for optimizable circulators
% inherits from CircGoal and OptNLBranch
%
% ------ PROPERTIES ------
%
% Protected Constant :
% harmonics 
% phases
% fpoints
% def_term
%
% Set Protected:
% load (OptResistor)
%
% Protected :
% optimsetup
% s_f       ->  most recent calculated s param  
%
% Public :
% ftest 
% plot_tools -> has to be a CircOptPlot instance
%
% ------ METHODS ------
%
% Public: 
% ABCD(freq)        -> calculates ABCD matrix
% s_f = calculate_S_lin_response(obj) -> get response for all f_test
%
% Protected :
%
% calculate_frf()   -> calculates ftest
% n_freqs()         -> calculates number of frequencies


    properties (Access=protected,Constant)

        harmonics=2;

        phases=[0 -120 -240]; 
        
        fpoints=201;
        
        def_term=1;
        
    end

    properties (Access=protected) 
        
        optimsetup=struct();
        s_f;
        
    end %optim variables

    properties 

        f_test;
        
        plot_tools;
        
    end
    
    properties (Access=protected) 

       load OptResistor;

    end % design parameters
    
    methods

        function obj=OptCirc(varargin)
        
            obj=obj@CircGoal(varargin{:});
            
            obj.load=OptResistor('value',OptCirc.def_term);
            
            obj.load.optimizable=false;
            
            listener(obj.load,'ValueUpdate',@obj.callback_term);
            
        end
        
        function set.load(obj,value)
            
            if ~isa(value,'OnePortPassive')
               
                error(strcat("load property in OptCirc has to be",...
                    " a member of OnePortPassive"));
            else
                
                obj.load=value;
                
            end
            
        end
              
        function set.plot_tools(obj,value)
        
            if ~isa(value,'OptPlot')
                
                error("plot_tools property has to be a member of OptPlot");
                
            else
                
                obj.plot_tools=value;
                
            end
        end
        
        s_f=calculate_S_lin_response(obj);

        test(obj);
        
    end
    
    methods (Access=protected)
        
        function callback_goal(obj,~,~)
            
            obj.init_goal('order',obj.order,...
                'iso_bandwidth',obj.iso_bandwidth,...
                'tx_bandwidth',obj.tx_bandwidth,...
                'f_center',obj.f_center,...
                'tx_direction',obj.tx_direction);
            
            obj.calculate_frf;
            
            if ~isempty(obj.plot_tools)
                
                if ~strcmp(obj.plot_tools.type,"none")
                    
                    obj.plot_tools.reset_plot;
                    
                end
                
            end
        
        end
        
        calculate_frf(obj);
        
        function n=n_freqs(obj)
        
            n=2*obj.harmonics+1;
            
        end
        
        function x=error_function(obj)
            
            s21=[obj.s_f(2,1,:)];
            err_IL=obj.ILgoal.error_function(s21(obj.ILgoal.test_indexes));
            
            s12=[obj.s_f(1,2,:)];
            err_ISO=obj.ISOgoal.error_function(s12(obj.ISOgoal.test_indexes));
            
            s11=[obj.s_f(1,1,:)];
            err_RL1=obj.RLgoal.error_function(s11(obj.RLgoal.test_indexes));
            
            s22=[obj.s_f(2,2,:)];
            err_RL2=obj.RLgoal.error_function(s22(obj.RLgoal.test_indexes));
            
            err_RL=(err_RL1+err_RL2)/2;
            
            err=err_IL+e
            
        end
        
    end
    
end
